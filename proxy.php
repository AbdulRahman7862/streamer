<?php
/**
 * proxy.php — Industry-Grade Proxy with Token/Alias Verification
 *
 * This script:
 *   - Accepts an "alias" and "token" via GET (generated by generateToken()).
 *   - Verifies the token using a shared secret key and retrieves the target URL from the session.
 *   - Uses cURL to fetch remote content (supporting GET, POST, etc.).
 *   - Rewrites the remote document by injecting a <base> tag into the <head> and converting
 *     relative resource URLs into absolute URLs. For <a> links, it wraps the absolute URL in a proxy token.
 *
 * IMPORTANT:
 *   - The secret key ('Ydfsdgfdg!£@£!@£@!£@£') must match that used in generateToken().
 *   - Adjust the $allowedDomains array as needed.
 */

error_reporting(E_ALL);
ini_set('display_errors', 1);

session_start(); // Needed for $_SESSION['url_map']

// Allow cross-origin requests (adjust if needed)
header("Access-Control-Allow-Origin: *");

// --- Step 1. Validate incoming alias and token ---
if (!isset($_GET['alias']) || !isset($_GET['token'])) {
    header("HTTP/1.1 400 Bad Request");
    exit("Missing alias or token parameters.");
}

$alias = $_GET['alias'];
$token = $_GET['token'];
$secretKey = 'Ydfsdgfdg!£@£!@£@!£@£';

// Decode the token (originally URL-encoded then base64-encoded as "expiration:signature")
$decodedToken = base64_decode(urldecode($token));
if (!$decodedToken) {
    header("HTTP/1.1 400 Bad Request");
    exit("Invalid token encoding.");
}
$parts = explode(":", $decodedToken, 2);
if (count($parts) !== 2) {
    header("HTTP/1.1 400 Bad Request");
    exit("Invalid token format.");
}
list($expiration, $signature) = $parts;
if (time() > (int)$expiration) {
    header("HTTP/1.1 400 Bad Request");
    exit("Token expired.");
}
$expectedSignature = hash_hmac('sha256', $alias . $expiration, $secretKey);
if (!hash_equals($expectedSignature, $signature)) {
    header("HTTP/1.1 400 Bad Request");
    exit("Invalid token signature.");
}

// --- Step 2. Retrieve the target URL from session mapping ---
if (!isset($_SESSION['url_map'][$alias])) {
    header("HTTP/1.1 400 Bad Request");
    exit("Alias not found.");
}
$targetUrl = $_SESSION['url_map'][$alias];
// Optionally, for one-time use, you can remove the mapping:
// unset($_SESSION['url_map'][$alias]);

// --- Step 3. Define the Proxy Class ---
class Proxy
{
    private $targetUrl;
    private $allowedDomains;
    
    public function __construct($url, array $allowedDomains = [])
    {
        $this->allowedDomains = $allowedDomains;
        if (!$this->isValidUrl($url)) {
            throw new Exception("Invalid URL: " . $url);
        }
        if (!$this->isAllowedDomain($url)) {
            throw new Exception("Access to the requested domain is not allowed.");
        }
        $this->targetUrl = $url;
    }
    
    private function isValidUrl($url)
    {
        return filter_var($url, FILTER_VALIDATE_URL) !== false;
    }
    
    private function isAllowedDomain($url)
    {
        if (empty($this->allowedDomains)) {
            return true;
        }
        $host = parse_url($url, PHP_URL_HOST);
        foreach ($this->allowedDomains as $allowed) {
            if (stripos($host, $allowed) !== false) {
                return true;
            }
        }
        return false;
    }
    
    public function process()
    {
        try {
            $method = $_SERVER['REQUEST_METHOD'];
            $data = null;
            if (in_array($method, ['POST', 'PUT', 'PATCH'])) {
                $data = file_get_contents('php://input');
            }
            
            // Fetch remote content (headers and body).
            list($rawHeaders, $body) = $this->fetchRemote($method, $data);
            $headers = $this->parseHeaders($rawHeaders);
            
            // Send the status and response headers to the client.
            $this->sendStatusHeader($headers);
            $this->sendHeaders($headers);
            
            // Only rewrite HTML responses.
            $contentType = $this->getHeaderValue($headers, 'Content-Type');
            if ($contentType && stripos($contentType, 'text/html') !== false) {
                $rewritten = $this->rewriteDocument($body);
                if (trim($rewritten) !== '') {
                    $body = $rewritten;
                }
            }
            
            echo $body;
        } catch (Exception $ex) {
            error_log("Proxy Error: " . $ex->getMessage());
            header("HTTP/1.1 500 Internal Server Error");
            exit("An error occurred while processing your request: " . $ex->getMessage());
        }
    }
    
    // Fetch the remote response and split headers from body.
    private function fetchRemote($method, $data = null)
    {
        $ch = curl_init();
        curl_setopt($ch, CURLOPT_URL, $this->targetUrl);
        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch, CURLOPT_HEADER, true);
        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);
        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);
        curl_setopt($ch, CURLOPT_TIMEOUT, 30);
        curl_setopt($ch, CURLOPT_USERAGENT, $_SERVER['HTTP_USER_AGENT'] ?? 'PHP Proxy');
        // Automatically decode compressed responses.
        curl_setopt($ch, CURLOPT_ENCODING, '');
        
        $forwardHeaders = $this->prepareRequestHeaders();
        if (!empty($forwardHeaders)) {
            curl_setopt($ch, CURLOPT_HTTPHEADER, $forwardHeaders);
        }
        if (in_array($method, ['POST', 'PUT', 'PATCH']) && $data !== null) {
            curl_setopt($ch, CURLOPT_POSTFIELDS, $data);
        }
        
        $response = curl_exec($ch);
        if (curl_errno($ch)) {
            throw new Exception("cURL error: " . curl_error($ch));
        }
        $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);
        curl_close($ch);
        $rawHeaders = substr($response, 0, $headerSize);
        $body = substr($response, $headerSize);
        return [$rawHeaders, $body];
    }
    
    // Parse raw headers into an associative array.
    private function parseHeaders($rawHeaders)
    {
        $headers = [];
        $lines = explode("\r\n", $rawHeaders);
        foreach ($lines as $line) {
            if (strpos($line, ':') !== false) {
                list($key, $val) = explode(":", $line, 2);
                $headers[trim($key)] = trim($val);
            } elseif (!empty($line)) {
                $headers['Status'] = $line;
            }
        }
        return $headers;
    }
    
    private function prepareRequestHeaders()
    {
        $headers = [];
        if (function_exists('getallheaders')) {
            $clientHeaders = getallheaders();
        } else {
            $clientHeaders = [];
            foreach ($_SERVER as $name => $value) {
                if (substr($name, 0, 5) === 'HTTP_') {
                    $headerName = str_replace(' ', '-', ucwords(strtolower(str_replace('_', ' ', substr($name, 5)))));
                    $clientHeaders[$headerName] = $value;
                }
            }
        }
        foreach ($clientHeaders as $name => $value) {
            if (in_array(strtolower($name), ['host', 'content-length'])) {
                continue;
            }
            $headers[] = "$name: $value";
        }
        return $headers;
    }
    
    private function sendStatusHeader($headers)
    {
        if (isset($headers['Status'])) {
            header($headers['Status']);
        }
    }
    
    private function sendHeaders($headers)
    {
        $excluded = ['transfer-encoding', 'content-length', 'connection', 'content-encoding'];
        foreach ($headers as $name => $value) {
            if (in_array(strtolower($name), $excluded)) {
                continue;
            }
            if ($name === 'Status') {
                continue;
            }
            header("$name: $value");
        }
    }
    
    private function getHeaderValue($headers, $headerName)
    {
        foreach ($headers as $name => $value) {
            if (strtolower($name) === strtolower($headerName)) {
                return $value;
            }
        }
        return null;
    }
    
    /**
     * Rewrite the remote document by injecting a <base> tag into the <head> and converting relative URLs.
     * For anchor (<a>) tags, wrap the absolute URL in a proxy token so that clicks are proxied.
     * For other tags (like <script>, <link>, <img>), simply convert to absolute URLs.
     */
    private function rewriteDocument($html)
    {
        libxml_use_internal_errors(true);
        $doc = new DOMDocument();
        // Load the HTML without forcing removal of implied tags.
        if (!$doc->loadHTML($html)) {
            return $html;
        }
        libxml_clear_errors();
        
        // Compute the base href from the target URL.
        $baseHref = $this->getBaseHref($this->targetUrl);
        
        // Inject (or update) a <base> tag in the <head>.
        $head = $doc->getElementsByTagName('head')->item(0);
        if ($head) {
            $baseTags = $head->getElementsByTagName('base');
            if ($baseTags->length === 0) {
                $base = $doc->createElement('base');
                $base->setAttribute('href', $baseHref);
                $head->insertBefore($base, $head->firstChild);
            } else {
                $baseTags->item(0)->setAttribute('href', $baseHref);
            }
        }
        
        // Process all elements with a "src" or "href" attribute.
        $all = $doc->getElementsByTagName('*');
        foreach ($all as $el) {
            // Process href attributes.
            if ($el->hasAttribute('href')) {
                $url = $el->getAttribute('href');
                $absoluteUrl = $this->resolveUrl($this->targetUrl, $url);
                if (strtolower($el->tagName) === 'a') {
                    // For anchor tags, wrap the absolute URL in a proxy token.
                    $el->setAttribute('href', $this->generateProxyToken($absoluteUrl));
                } else {
                    // For other tags, set the href to the absolute URL.
                    $el->setAttribute('href', $absoluteUrl);
                }
            }
            // Process src attributes.
            if ($el->hasAttribute('src')) {
                $url = $el->getAttribute('src');
                $absoluteUrl = $this->resolveUrl($this->targetUrl, $url);
                $el->setAttribute('src', $absoluteUrl);
            }
        }
        
        return $doc->saveHTML();
    }
    
    /**
     * Compute a base href from a given URL.
     * Returns a string like "https://www.example.com/" or "https://www.example.com/subdir/".
     */
    private function getBaseHref($url)
    {
        $parts = parse_url($url);
        if (!isset($parts['scheme']) || !isset($parts['host'])) {
            return $url;
        }
        $base = $parts['scheme'] . '://' . $parts['host'];
        if (isset($parts['path'])) {
            // Get the directory portion (ensuring it ends with a slash)
            $dir = rtrim(dirname($parts['path']), '/\\') . '/';
            $base .= $dir;
        } else {
            $base .= '/';
        }
        return $base;
    }
    
    private function resolveUrl($base, $relative)
    {
        // If $relative is already absolute, return it.
        if (parse_url($relative, PHP_URL_SCHEME) !== null) {
            return $relative;
        }
        if (substr($relative, 0, 2) === '//') {
            $scheme = parse_url($base, PHP_URL_SCHEME);
            return $scheme . ':' . $relative;
        }
        $baseParts = parse_url($base);
        $baseScheme = isset($baseParts['scheme']) ? $baseParts['scheme'] : '';
        $baseHost   = isset($baseParts['host']) ? $baseParts['host'] : '';
        $basePath   = isset($baseParts['path']) ? $baseParts['path'] : '';
        $basePath   = preg_replace('#/[^/]*$#', '/', $basePath);
        $path = (substr($relative, 0, 1) === '/') ? $relative : $basePath . $relative;
        $path = preg_replace('#/\.?/#', '/', $path);
        $path = preg_replace('#/(?!\.\.)[^/]+/\.\./#', '/', $path);
        return $baseScheme . '://' . $baseHost . $path;
    }
    
    private function generateProxyToken($url)
    {
        // Use the same secret key as in generateToken().
        $secretKey = 'Ydfsdgfdg!£@£!@£@!£@£';
        $alias = bin2hex(random_bytes(8));
        $_SESSION['url_map'][$alias] = $url;
        $expiration = time() + 86400; // 24 hours expiration
        $signature = hash_hmac('sha256', $alias . $expiration, $secretKey);
        return 'proxy.php?alias=' . urlencode($alias) . '&token=' . urlencode(base64_encode("$expiration:$signature"));
    }
}

// --- Step 4. Instantiate and run the proxy ---
// Adjust allowed domains as needed.
$allowedDomains = [
    'vidbinge.com',
    'novafork.com',
    'catflix.su/home',
    'cinemadeck.com',
    'popcornmovies.to',
    'nepu.to',
    'rgshows.me',
    'broflix.cc',
    'freek.to',
    'cineby.ru',
    'rivestream.live',
    'fmovies-hd.to',
    'flixwave.watch',
    'bflix.sh',
    'faragski.com',
    'watch.autoembed.cc',
    'cinebook.xyz',
    'hydrahd.com',
    'hianime.to',
    'yukiwatch.su',
    'aniwatchtv.to',
    'animetsu.cc',
    'kaido.to',
    'anicrush.to',
    'rivekun.rivestream.live',
    'kickassanime.am',
    'gogoanime3.co',
    'mangadex.org',
    'comick.io',
    'mangareader.to',
    'mangago.me',
    'mangafire.to',
    'allmanga.to',
    'mangakakalot.com',
    'asuracomic.net',
    'thetvapp.to',
    'tv247.us',
    'usatvgo.live',
    'en12.sportplus.live',
    'the.streameast.app',
    'v2.sportsurge.net',
    'disneyplus.com'
    // Add additional allowed domains if required.
];

try {
    $proxy = new Proxy($targetUrl, $allowedDomains);
    $proxy->process();
} catch (Exception $e) {
    error_log("Proxy Initialization Error: " . $e->getMessage());
    header("HTTP/1.1 400 Bad Request");
    exit("Error: " . htmlspecialchars($e->getMessage()));
}
?>
